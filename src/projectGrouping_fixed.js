const path = require("path");\nconst fs = require("fs");\nconst pathModule = require("path");\n\n// Load project configuration\nlet projectConfig;\n\ntry {\n  const configPath = pathModule.join(__dirname, "../config/projectConfig.json");\n  if (fs.existsSync(configPath)) {\n    projectConfig = JSON.parse(fs.readFileSync(configPath, "utf8"));\n  } else {\n    projectConfig = {\n      projectMappings: {},\n      blacklist: [],\n      waitlist: []\n    };\n  }\n} catch (error) {\n  console.warn("Could not load project configuration file:", error.message);\n  projectConfig = {\n    projectMappings: {},\n    blacklist: [],\n    waitlist: []\n  };\n}\n\nfunction extractProjectName(command) {\n  // Check blacklist first\n  for (const blacklisted of projectConfig.blacklist) {\n    if (command.includes(blacklisted)) {\n      return null; // Skip blacklisted processes\n    }\n  }\n\n  // Check project mappings\n  for (const [projectName, projectInfo] of Object.entries(projectConfig.projectMappings)) {\n    for (const pattern of projectInfo.patterns) {\n      if (command.includes(pattern)) {\n        return projectInfo.displayName || projectName;\n      }\n    }\n  }\n\n  if (\n    command.includes("Visual Studio Code") ||\n    command.includes("Code Helper")\n  ) {\n    return "Visual Studio Code";\n  }\n\n  if (command.includes("qwen")) {\n    return "Qwen";\n  }\n\n  if (command.includes(".nvm") || command.includes("/nvm/")) {\n    return "NVM";\n  }\n\n  if (\n    (command.startsWith("node ") || command.includes("node ")) &&\n    !command.includes("/Users/") &&\n    !command.includes("/home/") &&\n    command.includes(" ")\n  ) {\n    const nodeMatch = command.match(/node\s+([^\s]+)/);\n    if (nodeMatch && nodeMatch[1]) {\n      const file = nodeMatch[1];\n      if (file.includes("/")) {\n        const pathParts = file.split("/");\n        if (pathParts.length > 1) {\n          for (let i = 0; i < pathParts.length - 1; i++) {\n            if (isValidProjectName(pathParts[i])) {\n              return `node-${pathParts[i]}`;\n            }\n          }\n          // If we couldn't determine project name from path, try to get it from package.json\n          const projectFromPackageJson = getProjectNameFromPackageJson(file);\n          if (projectFromPackageJson) {\n            return projectFromPackageJson;\n          }\n          return "node-project";\n        } else {\n          return "node";\n        }\n      } else {\n        return "node";\n      }\n    }\n    return "node";\n  }\n\n  if (command.includes("node_modules")) {\n    const normalizedCommand = command.replace(//g, "/");\n    const nodeModulesIndex = normalizedCommand.indexOf("node_modules");\n\n    if (nodeModulesIndex !== -1) {\n      const beforeNodeModules = normalizedCommand.substring(\n        0,\n        nodeModulesIndex\n      );\n      const pathParts = beforeNodeModules\n        .split("/")\n        .filter(\n          (part) =>\n            part !== "." &&\n            part !== ".." &&\n            ![\n              ".",\n              "..",\n              "node_modules",\n              "src",\n              "dist",\n              "build",\n              "public",\n              "lib",\n              "test",\n              "tests",\n              "spec",\n              "bin",\n            ].includes(part)\n        );\n\n      for (let i = pathParts.length - 1; i >= 0; i--) {\n        if (isValidProjectName(pathParts[i])) {\n          return pathParts[i];\n        }\n      }\n    }\n  }\n\n  const normalizedCommand = command.replace(//g, "/");\n  const pathSegments = normalizedCommand.split("/");\n\n  let userHomeIndex = -1;\n  for (let i = 0; i < pathSegments.length; i++) {\n    if (["Users", "home", "root"].includes(pathSegments[i])) {\n      userHomeIndex = i;\n      break;\n    }\n  }\n\n  if (userHomeIndex !== -1 && userHomeIndex + 2 < pathSegments.length) {\n    const pathAfterUser = pathSegments.slice(userHomeIndex + 2);\n\n    const validProjectNames = [];\n    for (const segment of pathAfterUser) {\n      if (isValidProjectName(segment)) {\n        validProjectNames.push(segment);\n      }\n    }\n\n    if (normalizedCommand.includes("node_modules")) {\n      const nodeModulesIndex = normalizedCommand.indexOf("node_modules");\n\n      for (const project of [...validProjectNames].reverse()) {\n        if (normalizedCommand.indexOf(project) < nodeModulesIndex) {\n          return project;\n        }\n      }\n    } else {\n      if (validProjectNames.length > 0) {\n        return validProjectNames[validProjectNames.length - 1];\n      }\n    }\n  }\n\n  const commandParts = command.split(" ");\n  for (const part of commandParts) {\n    if (\n      part.includes("/") &&\n      !part.startsWith("http") &&\n      !part.includes("node_modules")\n    ) {\n      const normalizedPath = part.replace(//g, "/");\n      const pathParts = normalizedPath\n        .split("/")\n        .filter(\n          (part) =>\n            part !== "." &&\n            part !== ".." &&\n            ![\n              ".",\n              "..",\n              "node_modules",\n              "src",\n              "dist",\n              "build",\n              "public",\n              "lib",\n              "test",\n              "tests",\n              "spec",\n              "bin",\n            ].includes(part)\n        );\n\n      for (let i = pathParts.length - 2; i >= 0; i--) {\n        if (pathParts[i] && isValidProjectName(pathParts[i])) {\n          return pathParts[i];\n        }\n      }\n    }\n  }\n\n  const nestedPathLikeParts = command.match(\n    //(?:home|Users|root)/[^/\s]+/([^/\s]+)/[^/\s]+/g\n  );\n  if (nestedPathLikeParts) {\n    for (const part of nestedPathLikeParts) {\n      const pathParts = part.split("/");\n      if (pathParts.length >= 4) {\n        const projectName = pathParts[3];\n        if (isValidProjectName(projectName)) {\n          return projectName;\n        }\n      }\n    }\n  }\n\n  const directPathLikeParts = command.match(\n    //(?:home|Users|root)/[^/\s]+/([^/\s]+)/g\n  );\n  if (directPathLikeParts) {\n    for (const part of directPathLikeParts) {\n      const projectName = part.split("/").pop();\n      if (isValidProjectName(projectName)) {\n        return projectName;\n      }\n    }\n  }\n\n  // As a fallback, try to determine project name from package.json if command contains a file path\n  for (const part of command.split(" ")) {\n    if (part.includes("/") && !part.startsWith("http")) {\n      const projectFromPackageJson = getProjectNameFromPackageJson(part);\n      if (projectFromPackageJson) {\n        return projectFromPackageJson;\n      }\n    }\n  }\n\n  return "other-processes";\n}\n\n/**\n * Attempts to read the package.json file from the same directory as the given file path\n * and return the project name from the 'name' field.\n * @param {string} filePath - Path to a JavaScript file that might belong to a Node.js project\n * @returns {string|null} - Project name from package.json or null if not found\n */\nfunction getProjectNameFromPackageJson(filePath) {\n  try {\n    // Get the absolute path of the directory containing the file\n    const fileDir = path.dirname(path.resolve(filePath));\n    \n    // Search up the directory tree for a package.json file\n    let currentDir = fileDir;\n    \n    while (currentDir !== path.dirname(currentDir)) { // Stop when reaching the root directory\n      const packageJsonPath = path.join(currentDir, "package.json");\n      \n      if (fs.existsSync(packageJsonPath)) {\n        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));\n        \n        if (packageJson.name && isValidProjectName(packageJson.name)) {\n          return packageJson.name;\n        }\n        break; // Stop searching once we find a package.json file\n      }\n      \n      currentDir = path.dirname(currentDir);\n    }\n    \n    return null;\n  } catch (error) {\n    // If any error occurs (e.g., no permission, invalid JSON), continue with other methods\n    return null;\n  }\n}\n\nfunction isValidProjectName(name) {\n  const invalidNames = [\n    "node",\n    "nodejs",\n    "node_modules",\n    "npm",\n    "yarn",\n    "pnpm",\n    "index",\n    "app",\n    "server",\n    "main",\n    "start",\n    "index.js",\n    "app.js",\n    "server.js",\n    "main.js",\n    "start.js",\n    "lib",\n    "bin",\n    "sbin",\n    "src",\n    "dist",\n    "build",\n    "public",\n    "test",\n    "tests",\n    "spec",\n    "docs",\n    "doc",\n    "config",\n    "configs",\n    "conf",\n    "package",\n    "packages",\n    "home",\n    "Users",\n    "root",\n    "tmp",\n    "temp",\n    "Library",\n    "Applications",\n    "System",\n    "usr",\n    "etc",\n    "var",\n    "opt",\n    "home",\n    "Desktop",\n    "Documents",\n    "Downloads",\n    ".nvm",\n    ".npm",\n    ".yarn",\n    ".config",\n    ".vscode",\n    ".git",\n    "node_modules",\n    "vendor",\n    "target",\n    "out",\n    "release",\n    "debug",\n    "obj",\n    "node_modules",\n    "bower_components",\n  ];\n\n  return (\n    name.length >= 2 &&\n    !invalidNames.includes(name) &&\n    !name.startsWith(".") &&\n    !name.match(/^d+$/)\n  );\n}\n\nfunction groupProcessesByProject(processes) {\n  const grouped = {};\n\n  processes.forEach((process) => {\n    const projectName = extractProjectName(process.command);\n\n    // Skip blacklisted processes (they return null)\n    if (projectName === null) {\n      return;\n    }\n\n    if (!grouped[projectName]) {\n      grouped[projectName] = [];\n    }\n\n    grouped[projectName].push(process);\n  });\n\n  return grouped;\n}\n\nmodule.exports = {\n  extractProjectName,\n  groupProcessesByProject,\n};